











# 项目

## 项目架构

注册登记（TA）系统属于资金募集端的核心枢纽系统。在理财产品的整个生命周期内，管理投资账户，进行发行管理、份额管理、权益分配、费用计算。当前工商银行理财规模超3.4万亿元，随着规模增大带来以下问题：

（1）互联网渠道开拓引流，导致交易量激增（高并发、高可用）

（2）客户增多要求产品发行更具灵活性（可扩展）

（3）监管不断收紧，对系统的稳定性、可维护性提出更高要求（降级、限流、熔断等）

因此，项目组提出构建支持全产品、多渠道、7*24小时自动高效运作的新一代注册登记TA，该系统具备高性能、高可用、弹性扩展、全方位应用监控等功能。

负责群组 客户管理服务群组：

互联网渠道的客户账户开户交易通过联机发起，高峰交易量预估千级TPS，日常交易量预估为200TPS，流程如下：

  1)客户联机经TA应用前置接入，将信息转换成内部接口，发送到应用服务层。

  2)应用服务层将开户申请数据转发到客户服务群组（RPC调用），并异步存入DB，若联机同步处理性能超过系统设计性能，可同步转异步处理，将申请先落地DB，再逐笔处理，开户完成后再与销售商交互。

  3)客户服务群组接收到开户申请后，进行开户检查和确认，落地开户结果，并将结果信息返回应用服务层。

  4)应用服务层接收到客户服务群组的返回申请数据，实时转发给前置层，并异步将结果更新到DB中。

  5)前置收到返回报文后转换成外部接口，并返回合作方。





## 分布式框架

### 框架基本概念

分布式服务框架，如阿里巴巴的Dubbo，HSF，腾讯的Tars，京东的JSF，新浪的Motan，都已经是业界非常成熟的解决方案，其中开源的Dubbo和Motan受到了广大开发者的研究对象。

![image-20210310234126536](image-20210310234126536.png)

纵观这些服务框架，设计的基本思路都如上图，无非涉及provider发布注册，consumer订阅，调用发起，负载均衡，服务分流和监控等模块，并在此基础上增加了很多玩法，形成了各具特色的分布式服务框架设计。

无论是哪种SOA的架构设计，都离不开几个模块的功能，即Provider，Consumer，Registry，Gateway，负载均衡，服务分流，监控等，通过上述所讲，应该对这些功能模块有了初步的认识，下面就这些名词再作下介绍

（1）Provider：服务提供者，无论是业务服务，还是一个系统中公用的SAAS，都属于Provider

（2）Consumer：即发起调用的客户端

（3）Registry：服务注册中心，是分布式服务系统中的一个重要组成模块，管理Provider的Manager，在实际的运行环境中，服务注册中心Registry被动通知或Consumer主动询问，在Provider有节点宕机或新增节点时，客户端也可实时感知到，从而避免了某个Provider被无限调用或是无限闲置

（4）Gateway：网关也是分布式服务框架中不可或缺的部分，每种系统与框架都有自己的一套协议，当异构系统互相调用时，网关的作用即显现出来，Gateway接受各种外部HTTP请求，完成相应的权限校验，报文适配，路由转发到对应的Provider，再将Provider返回的结果传递给异构系统的Consumer，完成异构系统的互相调用

（5）负载均衡，服务分流：Consumer从Registry获得具体的Provider列表后，如何选取合适的Provider，取决与一定的负载均衡算法，常见的算法有轮询法，随机法，源地址哈希，加权轮询，加权随机等

（6）监控：接收来自Consumer和Provider异步上报的性能监控数据，对有风险的节点发出告警



### Dubbo

#### Dubbo 简介

Dubbo 实现了面向接口的代理 RPC 调用，并且可以配合 ZooKeeper 等组件实现服务注册和发现功能，并且拥有负载均衡、容错机制等。



#### Dubbo 总体架构



![image-20210309233150504](image-20210309233150504.png)



| 节点      | 角色说明                     |
| :-------- | :--------------------------- |
| Consumer  | 需要调用远程服务的服务消费方 |
| Registry  | 注册中心                     |
| Provider  | 服务提供方                   |
| Container | 服务运行的容器               |
| Monitor   | 监控中心                     |







#### Dubbo 分层架构

总的而言 Dubbo 分为三层，如果每一层再细分下去，一共有十层。

![image-20210309233911740](image-20210309233911740.png)



大的三层分别为 Business（业务层）、RPC 层、Remoting，并且还分为 API 层和 SPI 层。

分为大三层其实就是和我们知道的网络分层一样的意思，**只有层次分明，职责边界清晰才能更好的扩展**。

而分 API 层和 SPI 层这是 Dubbo 成功的一点，**采用微内核设计+SPI扩展**，使得有特殊需求的接入方可以自定义扩展，做定制的二次开发。

接下来咱们再来看看每一层都是干嘛的。

- Service，业务层，就是咱们开发的业务逻辑层。
- Config，配置层，主要围绕 ServiceConfig 和 ReferenceConfig，初始化配置信息。
- Proxy，代理层，服务提供者还是消费者都会生成一个代理类，使得服务接口透明化，代理层做远程调用和返回结果。
- Register，注册层，封装了服务注册和发现。
- Cluster，路由和集群容错层，负责选取具体调用的节点，处理特殊的调用要求和负责远程调用失败的容错措施。
- Monitor，监控层，负责监控统计调用时间和次数。
- Portocol，远程调用层，主要是封装 RPC 调用，主要负责管理 Invoker，Invoker代表一个抽象封装了的执行体，之后再做详解。
- Exchange，信息交换层，用来封装请求响应模型，同步转异步。
- Transport，网络传输层，抽象了网络传输的统一接口，这样用户想用 Netty 就用 Netty，想用 Mina 就用 Mina。
- Serialize，序列化层，将数据序列化成二进制流，当然也做反序列化。



**补充：**

**SPI**（Service Provider Interface），是 JDK 内置的一个服务发现机制，**它使得接口和具体实现完全解耦**。我们只声明接口，具体的实现类在配置中选择。

具体的就是你定义了一个接口，然后在`META-INF/services`目录下**放置一个与接口同名的文本文件**，文件的内容为**接口的实现类**，多个实现类用换行符分隔。这样就通过配置来决定具体用哪个实现！而 Dubbo SPI 还做了一些改进



#### Dubbo 调用过程

整体的流程，首先服务提供者 **Provider 启动然后向注册中心注册**自己所能提供的服务。

服务消费者 **Consumer 启动向注册中心订阅**自己所需的服务。然后注册中心将提供者元信息通知给 Consumer， 之后 Consumer 因为已经从注册中心获取提供者的地址，因此可以**通过负载均衡选择一个 Provider 直接调用** 。

之后服务提供方元数据变更的话**注册中心会把变更推送给服务消费者**。

服务提供者和消费者都会在内存中记录着调用的次数和时间，然后**定时的发送统计数据到监控中心**。



先从服务提供者开始，看看它是如何工作的。

##### 服务暴露过程

![image-20210309234247200](image-20210309234247200.png)

首先 Provider 启动，通过 Proxy 组件根据具体的协议 Protocol 将需要暴露出去的接口封装成 Invoker，Invoker 是 Dubbo 一个很核心的组件，代表一个可执行体。

然后再通过 Exporter 包装一下，这是为了在注册中心暴露自己套的一层，然后将 Exporter 通过 Registry 注册到注册中心。这就是整体服务暴露过程。



##### 消费过程

接着我们来看消费者调用流程（把服务者暴露的过程也在图里展示出来了，这个图其实算一个挺完整的流程图了）。

![image-20210309234347621](image-20210309234347621.png)

首先消费者启动会向注册中心拉取服务提供者的元信息，然后调用流程也是从 Proxy 开始，毕竟都需要代理才能无感知。

Proxy 持有一个 Invoker 对象，调用 invoke 之后需要通过 Cluster 先从 Directory 获取所有可调用的远程服务的 Invoker 列表，如果配置了某些路由规则，比如某个接口只能调用某个节点的那就再过滤一遍 Invoker 列表。

剩下的 Invoker 再通过 LoadBalance 做负载均衡选取一个。然后再经过 Filter 做一些统计什么的，再通过 Client 做数据传输，比如用 Netty 来传输。

传输需要经过 Codec 接口做协议构造，再序列化。最终发往对应的服务提供者。

服务提供者接收到之后也会进行 Codec 协议处理，然后反序列化后将请求扔到线程池处理。某个线程会根据请求找到对应的 Exporter ，而找到 Exporter 其实就是找到了 Invoker，但是还会有一层层 Filter，经过一层层过滤链之后最终调用实现类然后原路返回结果。



### RPC

#### 知道什么是 RPC 么？

RPC 就是 Remote Procedure Call，远程过程调用，它相对应的是本地过程调用。



#### 如何设计一个 RPC 框架

大致上一个 RPC 框架需要做的就是约定要通信协议，序列化的格式、容错机制、负载均衡策略、监控运维和一个注册中心。



##### 服务消费者

首先消费者面向接口编程，需要得知有哪些接口可以调用，可以通过**公用 jar 包**的方式来维护接口。

接口具体的实现交由框架处理了。需要来个**代理类**，消费者只管调用方法及传参，其他事项由代理搞定。

代理通过**注册中心**知晓可以调用哪些服务提供方。

一般而言提供方提供方都是集群部署，所以调用方需要通过**负载均衡策略**来选择一个调用。

还需要有**容错机制**，以应对远程调用过程中的网络等问题。

还要和服务提供方**约定一个协议**，例如我们就用 HTTP 来通信就好啦，也就是大家要讲一样的话，不然可能听不懂了。

当然序列化必不可少，毕竟我们本地的结构是“立体”的，需要序列化之后才能传输，因此还需要**约定序列化格式**。

并且这过程中间可能还需要掺入一些 **Filter，来作一波统一的处理**，例如调用计数啊等等。

这些都是框架需要做的，让消费者像在调用本地方法一样，无感知。



##### 服务提供者

服务提供者要**实现对应的接口**。

然后需要把自己的接口暴露出去，向**注册中心注册自己**，暴露自己所能提供的服务。

然后有消费者请求过来需要处理，提供者需要用和消费者**协商好的协议**来处理这个请求，然后做**反序列化**。

序列化完的请求应该**扔到线程池里面做处理**，某个线程接受到这个请求之后找到对应的实现调用，然后再**将结果原路返回**。



##### 注册中心

上面其实我们都提到了注册中心，这东西就相当于一个平台，大家在上面暴露自己的服务，也在上面得知自己能调用哪些服务。

当然还能做配置中心，将配置集中化处理，动态变更通知订阅者。



##### 监控运维

面对众多的服务，精细化的监控和方便的运维必不可少。





## 分布式事务

熟悉分布式事务，了解SAGA、TCC、可靠消息最终一致性等方案并有实际应用经验







## 数据库

熟悉Mysql，具有sql优化、索引优化、

## 分库分表

分库分表、性能调优、数据库灾备等项目经验

1)客户份额库按重要合作方重要交易独立部署原则，互联网渠道交易量大的阿里、腾讯的T+0产品分别独立部署。

2)货币T+0产品按照TA账号一致性hash离散划分，避免明星产品的热点数据冲击。

3)T+1类型产品和其他合作方T+0产品的客户份额数据合并集中部署，不分库。

4)客户库水平拆分：按数据均匀存储，分散热点原则，客户库按TA账户进行一致性Hash算法离散划分。





## AOP面向切面

结合Spring中的IoC、AOP源码进行过研究学习



## 服务治理

**同步处理性能超过系统设计性能，可同步转异步处理**

- 服务注册发现：Eurake，Dobbo，Consul，ZooKeeper
- 服务配置：Spring Cloud Config，Archaius
- 服务熔断：Hystrix，resilience4j
- 网关：Zuul，Spring Cloud Gateway
- 负载均衡：Ribbon，Feign
- 追踪工具：Sleuth，Zipkin，Htrace
- 日志采集：logback，ElasticSearch
- 监控平台：Promethues，Kibana，grafna，Spring boot admin



![image-20210310234959531](image-20210310234959531.png)









## 日志&监控中心

1)对接工商银行监控平台及日志平台，确保系统正确接入行内监控平台，并基于平台完成系统运行情况监控

2)基于AOP面向切面完成上述公共工具设计及开发







## 缓存

能熟练应用Redis，了解Redis集群搭建（Redis Cluster），冷热备份等内容





## 消息中间件

消息中间件：了解Kafka并有实际应用经验，了解RocketMQ、RabbitMQ、ActiveMQ等



慢SQL排查优化



## 高性能



## 高可用



## 弹性扩展



## 负载均衡

了解Zookeeper、Nginx、SLB、F5等负载均衡组件



# 基础



## java基础

熟悉Java语言，能熟练应用HashMap等常用数据结构，以及JUC包下常用工具类

了解工厂模式、动态代理等常用的设计模式



## JVM

 熟悉JVM内存管理，熟悉常用的GC算法及回收器



## 多线程

熟悉并发编程，了解各种锁的底层原理，能熟练应用线程池以及JUC下并发工具类





## 运维知识

自动化布署运维：Git、Jenkins、Maven，有Devops落地实践经验

1)负责系统物理设备搭建等工作，包括数据库安装配置、基础运行环境搭建、配置文件统一管理等

2)落地DevOps，实现版本测试、交付、上线全流程自动化